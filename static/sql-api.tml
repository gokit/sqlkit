// mapFields defines a type for a map that exposes a Fields() method.
type mapFields map[string]interface{}

// Fields returns the map itself and provides a method to match the sql.TableField interface.
func (m mapFields) Fields() (map[string]interface{}, error) {
    return m, nil
}

// {{.Struct.Object.Name}}Fields defines an interface which exposes method to return a map of all
// attributes associated with the defined structure as decided by the structure.
type {{.Struct.Object.Name}}Fields  interface {
	Fields() (map[string]interface{}, error)
}

// {{.Struct.Object.Name}}Consumer defines an interface which accepts a map of data which will be consumed
// into the giving implementing structure as decided by the structure.
type {{.Struct.Object.Name}}Consumer interface {
	Consume(map[string]interface{}) error
}

// {{.Struct.Object.Name}}DB defines a structure which provide DB CRUD operations
// using sql as the underline db.
type {{.Struct.Object.Name}}DB struct{
  col string
  sx sql.DB
  dx *sql.SQL
  metrics metrics.Metrics
  table db.TableIdentity
}

// New returns a new instance of {{.Struct.Object.Name}}DB.
func New(table string, m metrics.Metrics, sx sql.DB, tm ...tables.TableMigration) *{{.Struct.Object.Name}}DB{
    dx := sql.New(m, sx, tm...)

    return &{{.Struct.Object.Name}}DB{
        sx: sx,
        dx: dx,
        col: table,
        metrics: m,
        table: db.TableName{Name: table},
    }
}

// Delete attempts to remove the record from the db using the provided publicID.
// Records using this DB must have a public id value, expressed either by a bson or json tag
// on the given {{.Struct.Package}}.{{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) Delete(ctx context.Context, publicID string) error {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.Delete")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.Delete"),metrics.With("publicID", publicID),metrics.WithTrace(m.End()))

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to delete record"),metrics.With("publicID", publicID),metrics.With("table", mdb.col),metrics.With("error", err.Error()))
        return err
    }

    if err := mdb.dx.Delete(mdb.table, "public_id", publicID); err != nil {
        mdb.metrics.Emit(metrics.Errorf("Failed to delete record"),metrics.With("table", mdb.col),metrics.With("publicID", publicID),metrics.With("error", err.Error()))
        return err
    }

    mdb.metrics.Emit(metrics.Info("Deleted record"),metrics.With("table", mdb.col),metrics.With("publicID", publicID))

    return nil
}

// Create attempts to add the record into the db using the provided instance of the
// {{.Struct.Package}}.{{.Struct.Object.Name}}.
// Records using this DB must have a public id value, expressed either by a bson or json tag
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) Create(ctx context.Context, elem {{.Struct.Package}}.{{.Struct.Object.Name}}) error {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.Create")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.Create"),metrics.With("publicID", elem.PublicID),metrics.WithTrace(m.End()))

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to create record"),metrics.With("publicID", elem.PublicID),metrics.With("table", mdb.col),metrics.With("error", err.Error()))
				return err
    }

    {{ if (hasFunc .Struct "Fields") }}
        if err := mdb.dx.Save(mdb.table, elem); err != nil {
            mdb.metrics.Emit(
                metrics.Errorf("Failed to create {{.Struct.Object.Name}} record"),
                metrics.With("table", mdb.col),
                metrics.With("elem", elem),
                metrics.With("error", err.Error()),
            )

            return err
        }

        mdb.metrics.Emit(metrics.Info("Create record"),
        metrics.With("table", mdb.col),
        metrics.With("elem", elem))
    {{else}}
        content := mapFields({{ mapoutFields .CreateAction "elem" "bson" "json" }})
        if err := mdb.dx.Save(mdb.table, content); err != nil {
            mdb.metrics.Emit(metrics.Errorf("Failed to create {{.Struct.Object.Name}} record"),metrics.With("table", mdb.col),metrics.With("query", content),metrics.With("error", err.Error()))
            return err
        }

        mdb.metrics.Emit(metrics.Info("Create record"),metrics.With("table", mdb.col),metrics.With("query", content))
    {{end}}

    return nil
}

// GetAll retrieves all records from the db and returns a slice of {{.Struct.Package}}.{{.Struct.Object.Name}} type.
// Records using this DB must have a public id value, expressed either by a bson or json tag
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) GetAll(ctx context.Context, order string, orderby string, page int, responsePerPage int)  ([]{{.Struct.Package}}.{{.Struct.Object.Name}}, int, error) {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.GetAll")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.GetAll"),metrics.WithTrace(m.End()))

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to retrieve record"),metrics.With("table", mdb.col),metrics.With("error", err.Error()))

        return nil, -1, err
    }

    var total int
    var ritems []{{.Struct.Package}}.{{.Struct.Object.Name}}

    {{ if (hasFunc .Struct "Consume") }}
        items, total, err := mdb.dx.GetAllPerPage(mdb.table, order, orderby, page, responsePerPage);
        if err != nil {
            mdb.metrics.Emit(metrics.Errorf("Failed to retrieve all records of {{.Struct.Object.Name}} type from db"),metrics.With("table", mdb.col),metrics.With("error", err.Error()))
            return nil, total, err
        }

        for _, item := range items {
            var elem {{.Struct.Package}}.{{.Struct.Object.Name}}
            if err := elem.Consume(item); err != nil {
                mdb.metrics.Emit(metrics.Errorf("Failed to consume record data for {{.Struct.Object.Name}} from db"),metrics.With("table", mdb.col),metrics.With("data", item),metrics.With("error", err.Error()))
                return nil, -1, err
            }
            ritems = append(ritems, elem)
        }
    {{else}}
        panic("{{.Struct.Object.Name.Name}} must implement {{.Struct.Object.Name.Name}}Consumer")
    {{end}}

    return ritems, total, nil
}

// GetByField retrieves a record from the db using the field key and value,
// returns the {{.Struct.Package}}.{{.Struct.Object.Name}} type.
// Records using this DB must have a public id value, expressed either by a bson or json tag
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) GetByField(ctx context.Context, key string, value string)  ({{.Struct.Package}}.{{.Struct.Object.Name}},  error) {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.Get")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.Get"),metrics.With(key, value),metrics.WithTrace(m.End()))

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to retrieve record"),metrics.With(key, value),metrics.With("table", mdb.col),metrics.With("error", err.Error()))

        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
    }

    var elem {{.Struct.Package}}.{{.Struct.Object.Name}}

    {{ if (hasFunc .Struct "Consume") }}
        if err := mdb.dx.Get(mdb.table, &elem, key, value); err != nil {
            mdb.metrics.Emit(metrics.Errorf("Failed to retrieve all records of {{.Struct.Object.Name.Name}} type from db"),
            metrics.With("table", mdb.col),
            metrics.With("error", err.Error()))

            return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
        }
    {{else}}
        panic("{{.Struct.Object.Name.Name}} must implement {{.Struct.Object.Name.Name}}Consumer")
    {{end}}

    return elem, nil
}

// Get retrieves a record from the db using the publicID and returns the {{.Struct.Package}}.{{.Struct.Object.Name}} type.
// Records using this DB must have a public id value, expressed either by a bson or json tag
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) Get(ctx context.Context, publicID string)  ({{.Struct.Package}}.{{.Struct.Object.Name}},  error) {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.Get")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.Get"),metrics.With("publicID", publicID),metrics.WithTrace(m.End()))


    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to retrieve record"),metrics.With("publicID", publicID),metrics.With("table", mdb.col),metrics.With("error", err.Error()))
        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
    }

    var elem {{.Struct.Package}}.{{.Struct.Object.Name}}

    {{ if ( hasFunc .Struct "Consume"  ) }}
        {{ $pfield := fieldByName .Struct "PublicID" }}
        {{ $ptag := getTag $pfield "sql" "json"}}

        if err := mdb.dx.Get(mdb.table, &elem, "{{$ptag.Value}}", publicID); err != nil {
            mdb.metrics.Emit(metrics.Errorf("Failed to retrieve all records of {{.Struct.Object.Name.Name}} type from db"),
            metrics.With("table", mdb.col),
            metrics.With("error", err.Error()))

            return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
        }
    {{else}}
        panic("{{.Struct.Object.Name.Name}} must implement {{.Struct.Object.Name.Name}}Consumer")
    {{end}}


    return elem, nil
}

// Update uses a record from the db using the publicID and returns the {{.Struct.Package}}.{{.Struct.Object.Name}} type.
// Records using this DB must have a public id value, expressed either by a bson or json tag
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) Update(ctx context.Context, publicID string, elem {{.Struct.Package}}.{{.Struct.Object.Name}}) error {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.Update")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.Update"),metrics.With("publicID", publicID),metrics.WithTrace(m.End()))

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to finish, context has expired"),metrics.With("table", mdb.col),metrics.With("public_id", publicID),metrics.With("error", err.Error()))
        return err
    }

    {{ $pfield := fieldByName .Struct "PublicID" }}
    {{ $ptag := getTag $pfield "sql" "json"}}

    {{ if ( hasFunc .Struct "Fields"  ) }}
        if err := mdb.dx.Update(mdb.table, elem, "{{$ptag.Value}}", publicID); err != nil {
            mdb.metrics.Emit(metrics.Errorf("Failed to update {{.Struct.Object.Name}} record"),metrics.With("query", elem),metrics.With("table", mdb.col),metrics.With("{{$ptag.Value}}", publicID),metrics.With("error", err.Error()))
            return err
        }
    {{else}}
        data := mapFields({{ mapoutFields .CreateAction "elem" "bson" "json" }})
        if err := mdb.dx.Update(mdb.table, data, "{{$ptag.Value}}", publicID); err != nil {
            mdb.metrics.Emit(metrics.Errorf("Failed to update {{.Struct.Object.Name}} record"),metrics.With("query", elem),metrics.With("table", mdb.col),metrics.With("{{$ptag.Value}}", publicID),metrics.With("error", err.Error()))
            return err
        }
    {{end}}


    mdb.metrics.Emit(metrics.Info("Update record"),metrics.With("table", mdb.col),metrics.With("{{$ptag.Value}}", publicID),metrics.With("query", elem))

    return nil
}

// Exec provides a function which allows the execution of a custom function against the table.
func (mdb *{{.Struct.Object.Name}}DB) Exec(ctx context.Context, fx func(*sql.SQL, sql.DB) error) error {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.Exec")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.Exec"),metrics.WithTrace(m.End()))

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to execute operation"),metrics.With("table", mdb.col),metrics.With("error", err.Error()))
        return err
    }

    if err := fx(mdb.dx, mdb.sx); err != nil {
        mdb.metrics.Emit(metrics.Errorf("Failed to execute operation"),metrics.With("table", mdb.col),metrics.With("error", err.Error()))
        return err
    }

    mdb.metrics.Emit(metrics.Info("Operation executed"),metrics.With("table", mdb.col))

    return nil
}
