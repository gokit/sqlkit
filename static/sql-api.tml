// mapFields defines a type for a map that exposes a Fields() method.
type mapFields map[string]interface{}

// Fields returns the map itself and provides a method to match the sql.TableField interface.
func (m mapFields) Fields() map[string]interface{} {
    return m
}

// {{.Struct.Object.Name}}Fields defines an interface which exposes method to return a map of all
// attributes associated with the defined structure as decided by the structure.
type {{.Struct.Object.Name}}Fields  interface {
	Fields() map[string]interface{}
}

// {{.Struct.Object.Name}}Consumer defines an interface which accepts a map of data which will be consumed
// into the giving implementing structure as decided by the structure.
type {{.Struct.Object.Name}}Consumer interface {
	Consume(map[string]interface{}) error
}

// IndexMigration defines a struct which contain index instruction for creating index fields
// for tables
type IndexMigration struct {
	Field     string `json:"field"`
	IndexName string `json:"index_name"`
}

// String returns the index query for the giving index migration.
func (index IndexMigration) String() string {
	return fmt.Sprintf("INDEX %s (%s)", index.Field, index.IndexName)
}

// FieldMigration defines a struct which defines the fields for a tableMigrations.
type FieldMigration struct {
	FieldName     string `json:"field_name"`
	FieldType     string `json:"field_type"`
	NotNull       bool   `json:"not_null"`
	PrimaryKey    bool   `json:"primary_key"`
	AutoIncrement bool   `json:"auto_increment"`
}

// String returns the index query for the giving field migration.
func (field FieldMigration) String() string {
	var b bytes.Buffer

	fmt.Fprintf(&b, "%s", field.FieldName)
	fmt.Fprintf(&b, " ")
	fmt.Fprintf(&b, "%s", field.FieldType)

	if field.NotNull {
		fmt.Fprintf(&b, " ")
		fmt.Fprintf(&b, "NOT NULL")
	}

	if field.PrimaryKey {
		fmt.Fprintf(&b, " ")
		fmt.Fprintf(&b, "PRIMARY KEY")
	}

	if field.AutoIncrement {
		fmt.Fprintf(&b, " ")
		fmt.Fprintf(&b, "AUTO_INCREMENT")
	}

	return b.String()
}


// Migration defines a struct which defines a query field to be run against.
type Migration struct {
	TableName   string           `json:"table_name"`
	Timestamped bool             `json:"timestamped"`
	Fields      []FieldMigration `json:"fields"`
	Indexes     []IndexMigration `json:"indexes"`
	Queries     []string         `json:"queries"` // complete sql queries which will be ran.
}

// String returns the index query for the giving table migration.
func (table Migration) String() string {
	var b bytes.Buffer

	if table.TableName != "" {
		fmt.Fprintf(&b, "CREATE TABLE IF NOT EXISTS %s (\n", table.TableName)

		total := len(table.Fields) - 1
		hasFields := table.Fields != nil

		for index, field := range table.Fields {
			fmt.Fprintf(&b, "\t%s", field.String())

			if index < total {
				fmt.Fprintf(&b, ",\n")
			}
		}

		if table.Timestamped {
			if hasFields {
				fmt.Fprint(&b, ",\n")
			}

			fmt.Fprint(&b, "\tcreated_at timestamp NOT NULL,\n")
			fmt.Fprint(&b, "\tupdated_at timestamp NOT NULL")

			if len(table.Indexes) != 0 && len(table.Fields) != 0 {
				fmt.Fprint(&b, ",")
			}
		}

		if len(table.Indexes) != 0 && len(table.Fields) != 0 {
			if !table.Timestamped {
				fmt.Fprint(&b, ",")
			}

			if hasFields {
				fmt.Fprint(&b, "\n")
			}

			totalIndexes := len(table.Indexes) - 1

			for index, ind := range table.Indexes {
				fmt.Fprintf(&b, "\t%s", ind.String())

				if index < totalIndexes {
					fmt.Fprintf(&b, ",\n")
				}
			}
		}

		fmt.Fprint(&b, "\n);\r\n")
	}

	if len(table.Queries) != 0 {
		fmt.Fprint(&b, "\r\n")

		for _, query := range table.Queries {
			// Attempt to swap in tablename incase of format string
			query = fmt.Sprintf(query, table.TableName)

			if strings.HasSuffix(query, ";") {
				fmt.Fprintf(&b, "%s\n", query)
				continue
			}

			fmt.Fprintf(&b, "%s;\n", query)
		}

		fmt.Fprint(&b, "\r\n")
	}

	return b.String()
}


// {{.Struct.Object.Name}}DB defines a structure which provide DB CRUD operations
// using sql as the underline db.
type {{.Struct.Object.Name}}DB struct{
  col string
  sx sql.DB
  dx *sql.SQL
  metrics metrics.Metrics
  table db.TableIdentity
}

// New returns a new instance of {{.Struct.Object.Name}}DB.
func New(table string, m metrics.Metrics, sx sql.DB, tm ...tables.TableMigration) *{{.Struct.Object.Name}}DB{
    dx := sql.New(m, sx, tm...)

    return &{{.Struct.Object.Name}}DB{
        sx: sx,
        dx: dx,
        col: table,
        metrics: m,
        table: db.TableName{Name: table},
    }
}

// Delete attempts to remove the record from the db using the provided publicID.
// Records using this DB must have a public id value, expressed either by a bson or json tag
// on the given {{.Struct.Package}}.{{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) Delete(ctx context.Context, publicID string) error {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.Delete")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.Delete"),metrics.With("publicID", publicID),metrics.WithTrace(m.End()))

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to delete record"),metrics.WithFields("publicID", publicID),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))
        return err
    }

    if err := mdb.dx.Delete(mdb.table, "public_id", publicID); err != nil {
        mdb.metrics.Emit(metrics.Errorf("Failed to delete record"),metrics.WithFields("table", mdb.col),metrics.WithFields("publicID", publicID),metrics.WithFields("error", err.Error()))
        return err
    }

    mdb.metrics.Emit(metrics.Info("Deleted record"),metrics.WithFields("table", mdb.col),metrics.WithFields("publicID", publicID))

    return nil
}

// Create attempts to add the record into the db using the provided instance of the
// {{.Struct.Package}}.{{.Struct.Object.Name}}.
// Records using this DB must have a public id value, expressed either by a bson or json tag
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) Create(ctx context.Context, elem {{.Struct.Package}}.{{.Struct.Object.Name}}) error {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.Create")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.Create"),metrics.With("publicID", elem.PublicID),metrics.WithTrace(m.End()))

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to create record"),metrics.WithFields("publicID", elem.PublicID),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))
				return err
    }

    if fields, ok := interface{}(elem).({{.Struct.Object.Name}}Fields); ok {
        if err := mdb.dx.Save(mdb.table, mapFields(fields.Fields())); err != nil {
            mdb.metrics.Emit(metrics.Errorf("Failed to create {{.Struct.Object.Name}} record"),metrics.WithFields("table", mdb.col),metrics.WithFields("elem", elem),metrics.WithFields("error", err.Error()))

            return err
        }

        mdb.metrics.Emit(metrics.Info("Create record"),metrics.WithFields("table", mdb.col),metrics.WithFields("elem", elem))

        return nil
    }

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")

        mdb.metrics.Emit(metrics.Errorf("Failed to create record"),metrics.WithFields("publicID", elem.PublicID),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))
        return err
    }

    content := mapFields({{ mapoutFields .CreateAction "elem" "bson" "json" }})

    if err := mdb.dx.Save(mdb.table, content); err != nil {
        mdb.metrics.Emit(metrics.Errorf("Failed to create {{.Struct.Object.Name}} record"),metrics.WithFields("table", mdb.col),metrics.WithFields("query", content),metrics.WithFields("error", err.Error()))
        return err
    }

    mdb.metrics.Emit(metrics.Info("Create record"),metrics.WithFields("table", mdb.col),metrics.WithFields("query", content))
    return nil
}

// GetAll retrieves all records from the db and returns a slice of {{.Struct.Package}}.{{.Struct.Object.Name}} type.
// Records using this DB must have a public id value, expressed either by a bson or json tag
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) GetAll(ctx context.Context, order string, orderby string, page int, responsePerPage int)  ([]{{.Struct.Package}}.{{.Struct.Object.Name}}, int, error) {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.GetAll")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.GetAll"),metrics.WithTrace(m.End()))

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to retrieve record"),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))

        return nil, -1, err
    }

    {{ if ( hasFunc .Struct "Consume"  ) }}
        var ritems []{{.Struct.Package}}.{{.Struct.Object.Name}}

        items, total, err := mdb.dx.GetAllPerPage(mdb.table, order, orderby, page, responsePerPage);
        if err != nil {
            mdb.metrics.Emit(metrics.Errorf("Failed to retrieve all records of {{.Struct.Object.Name}} type from db"),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))

            return nil, total, err
        }

        for _, item := range items {
            var elem {{.Struct.Package}}.{{.Struct.Object.Name}}

            if err := elem.Consume(item); err != nil {
                mdb.metrics.Emit(metrics.Errorf("Failed to consume record data for {{.Struct.Object.Name}} from db"),metrics.WithFields("table", mdb.col),metrics.WithFields("data", item),metrics.WithFields("error", err.Error()))

                return nil, -1, err
            }

            ritems = append(ritems, elem)
        }

        return ritems, total, nil
    {{ else }}
        var ritems []{{.Struct.Package}}.{{.Struct.Object.Name}}

        total, err := mdb.dx.GetAllPerPageBy(mdb.table, order, orderby, page, responsePerPage, func(rows *sqlx.Rows) error {
            for rows.Next() {
                var ritem {{.Struct.Package}}.{{.Struct.Object.Name}}

                if err := rows.StructScan(&ritem); err != nil {
                    mdb.metrics.Emit(metrics.Errorf(err),metrics.WithFields(metrics.Field{
                        "err":   err,
                        "table": mdb.table.Table(),
                    }))

                    return err
                }

                ritems = append(ritems, ritem)
            }

            return nil
        });

        if err != nil {
            mdb.metrics.Emit(metrics.Errorf("Failed to consume record data for {{.Struct.Object.Name}} from db"),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))

            return nil, total, err
        }

        return ritems, total, nil
    {{ end }}
}



// GetByField retrieves a record from the db using the field key and value,
// returns the {{.Struct.Package}}.{{.Struct.Object.Name}} type.
// Records using this DB must have a public id value, expressed either by a bson or json tag
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) GetByField(ctx context.Context, key string, value string)  ({{.Struct.Package}}.{{.Struct.Object.Name}},  error) {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.Get")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.Get"),metrics.With(key, value),metrics.WithTrace(m.End()))

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to retrieve record"),metrics.WithFields(key, value),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))

        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
    }

    item, err := mdb.dx.Get(mdb.table, key, value);
    if err != nil {
        mdb.metrics.Emit(metrics.Errorf("Failed to retrieve all records of {{.Struct.Object.Name}} type from db"),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))

        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
    }

    var elem {{.Struct.Package}}.{{.Struct.Object.Name}}

		if _, ok := elem.({{.Struct.Object.Name}}Consumer); !ok {
			return elem, errors.New("Only {{.Struct.Object.Name}}Consumer allowed")
		}

    if err := elem.Consume(item); err != nil {
        mdb.metrics.Emit(metrics.Errorf("Failed to consume record data for {{.Struct.Object.Name}} from db"),metrics.WithFields("table", mdb.col),metrics.WithFields("data", item),metrics.WithFields("error", err.Error()))

        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
    }

    return elem, nil
}

// Get retrieves a record from the db using the publicID and returns the {{.Struct.Package}}.{{.Struct.Object.Name}} type.
// Records using this DB must have a public id value, expressed either by a bson or json tag
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) Get(ctx context.Context, publicID string)  ({{.Struct.Package}}.{{.Struct.Object.Name}},  error) {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.Get")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.Get"),metrics.With("publicID", publicID),metrics.WithTrace(m.End()))


    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to retrieve record"),metrics.WithFields("publicID", publicID),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))
        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
    }

    {{ if ( hasFunc .Struct "Consume"  ) }}
        item, err := mdb.dx.Get(mdb.table, "public_id", publicID);
        if err != nil {
            mdb.metrics.Emit(metrics.Errorf("Failed to retrieve all records of {{.Struct.Object.Name}} type from db"),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))

            return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
        }

        var elem {{.Struct.Package}}.{{.Struct.Object.Name}}

        if err := elem.Consume(item); err != nil {
            mdb.metrics.Emit(metrics.Errorf("Failed to consume record data for {{.Struct.Object.Name}} from db"),metrics.WithFields("table", mdb.col),metrics.WithFields("data", item),metrics.WithFields("error", err.Error()))

            return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
        }

        return elem, nil
    {{ else }}

        var elem {{.Struct.Package}}.{{.Struct.Object.Name}}

        {{ $pfield := fieldByName .Struct "PublicID" }}
        {{ $ptag := getTag $pfield "sql" "json"}}

        if err := mdb.dx.GetBy(mdb.table, func(row *sqlx.Row) error {
            if err := row.StructScan(&elem); err != nil {
                mdb.metrics.Emit(metrics.Errorf(err),metrics.WithFields(metrics.Field{
                    "err":   err,
                    "table": mdb.table.Table(),
                }))

                return err
            }

            return nil
        }, "{{$ptag.Value}}", publicID); err != nil {
            mdb.metrics.Emit(metrics.Errorf("Failed to consume record data for {{.Struct.Object.Name}} from db"),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))

            return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
        }

        return elem, nil
    {{ end }}
}


// Update uses a record from the db using the publicID and returns the {{.Struct.Package}}.{{.Struct.Object.Name}} type.
// Records using this DB must have a public id value, expressed either by a bson or json tag
// on the given {{.Struct.Object.Name}} struct.
func (mdb *{{.Struct.Object.Name}}DB) Update(ctx context.Context, publicID string, elem {{.Struct.Package}}.{{.Struct.Object.Name}}) error {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.Update")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.Update"),metrics.With("publicID", publicID),metrics.WithTrace(m.End()))

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to finish, context has expired"),metrics.WithFields("table", mdb.col),metrics.WithFields("public_id", publicID),metrics.WithFields("error", err.Error()))
        return err
    }

    var data mapFields

    if fields, ok := interface{}(elem).({{.Struct.Object.Name}}Fields); ok {
        data = mapFields(fields.Fields())
    }else{
        data = mapFields({{ mapoutFields .CreateAction "elem" "bson" "json" }})
    }

    {{ $pfield := fieldByName .Struct "PublicID" }}
    {{ $ptag := getTag $pfield "sql" "json"}}

    if err := mdb.dx.Update(mdb.table, data, "{{$ptag.Value}}", publicID); err != nil {
        mdb.metrics.Emit(metrics.Errorf("Failed to update {{.Struct.Object.Name}} record"),metrics.WithFields("query", data),metrics.WithFields("table", mdb.col),metrics.WithFields("{{$ptag.Value}}", publicID),metrics.WithFields("error", err.Error()))
        return err
    }

    mdb.metrics.Emit(metrics.Info("Update record"),metrics.WithFields("table", mdb.col),metrics.WithFields("{{$ptag.Value}}", publicID),metrics.WithFields("query", data))

    return nil
}

// Exec provides a function which allows the execution of a custom function against the table.
func (mdb *{{.Struct.Object.Name}}DB) Exec(ctx context.Context, fx func(*sql.SQL, sql.DB) error) error {
    m := metrics.NewTrace("{{.Struct.Object.Name}}DB.Exec")
    defer mdb.metrics.Emit(metrics.Info("{{.Struct.Object.Name}}DB.Exec"),metrics.WithTrace(m.End()))

    if context.IsExpired(ctx) {
        err := fmt.Errorf("Context has expired")
        mdb.metrics.Emit(metrics.Errorf("Failed to execute operation"),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))
        return err
    }

    if err := fx(mdb.dx, mdb.sx); err != nil {
        mdb.metrics.Emit(metrics.Errorf("Failed to execute operation"),metrics.WithFields("table", mdb.col),metrics.WithFields("error", err.Error()))
        return err
    }

    mdb.metrics.Emit(metrics.Info("Operation executed"),metrics.WithFields("table", mdb.col))

    return nil
}
